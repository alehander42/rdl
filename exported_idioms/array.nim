typ(Sequence[T]):
  `<<`(a: T) -> Sequence[T]:                      self.`<<`(a)
  `[]`(a: Range[Int]) -> Sequence[T]:             self.`[]`(a)
  `[]`(a: Union[Int, Float]) -> T:                self.`[]`(a)
  `[]`(a: Int, b: Int) -> Sequence[T]:            self.`[]`(a, b)
  `&`[T, U](a: Sequence[U]) -> Sequence[T]:       self.`&`(a)
  `*`(a: Int) -> Sequence[T]:                     self.`*`(a)
  `*`(a: String) -> String:                       self.`*`(a)
  slice(a: Range[Int]) -> Sequence[T]:            self.slice(a)
  slice(a: Int) -> T:                             self.slice(a)
  slice(a: Int, b: Int) -> Sequence[T]:           self.slice(a, b)
  `[]=`(a: Int, b: T) -> T:                       self.`[]=`(a, b)
  `[]=`(a: Int, b: Int, c: T) -> T:               self.`[]=`(a, b, c)
  `[]=`(a: Range[Int], b: T) -> T:                self.`[]=`(a, b)
  assoc(a: T) -> Sequence[T]:                     self.assoc(a)
  at(a: Int) -> T:                                self.at(a)
  clear() -> Sequence[T]:                         self.clear()
  map[T, U](a: Block[U]) -> Sequence[U]:          self.map(a)
  map() -> Enumerator[T]:                         self.map()
  map_bang[T, U](a: Block[U]) -> Sequence[U]:     self.map_bang(a)
  map_bang() -> Enumerator[T]:                    self.map_bang()
  collect[T, U](a: Block[U]) -> Sequence[U]:      self.collect(a)
  collect() -> Enumerator[T]:                     self.collect()
  combination(a: Int, b: Block[Any]) -> Sequence[T]:self.combination(a, b)
  combination(a: Int) -> Enumerator[T]:           self.combination(a)
  push(a: T) -> Sequence[T]:                      self.push(a)
  compact() -> Sequence[T]:                       self.compact()
  compact_bang() -> Sequence[T]:                  self.compact_bang()
  concat(a: Sequence[T]) -> Sequence[T]:          self.concat(a)
  count() -> Int:                                 self.count()
  count(a: T) -> Int:                             self.count(a)
  count(a: Block[Bool]) -> Int:                   self.count(a)
  cycle(a: Optional[Int], b: Block[Any]) -> Any:  self.cycle(a, b)
  cycle(a: Optional[Int]) -> Enumerator[T]:       self.cycle(a)
  delete[T, U](a: U) -> T:                        self.delete(a)
  delete_at(a: Int) -> Sequence[T]:               self.delete_at(a)
  delete_if(a: Block[Bool]) -> Sequence[T]:       self.delete_if(a)
  delete_if() -> Enumerator[T]:                   self.delete_if()
  drop(a: Int) -> Sequence[T]:                    self.drop(a)
  drop_while(a: Block[Bool]) -> Sequence[T]:      self.drop_while(a)
  drop_while() -> Enumerator[T]:                  self.drop_while()
  each() -> Enumerator[T]:                        self.each()
  each(a: Block[Any]) -> Sequence[T]:             self.each(a)
  each_index(a: Block[Any]) -> Sequence[T]:       self.each_index(a)
  each_index() -> Enumerator[T]:                  self.each_index()
  empty_question() -> Bool:                       self.empty_quftion()
  fetch(a: Int) -> T:                             self.fetch(a)
  fetch[T, U](a: Int, b: U) -> U:                 self.fetch(a, b)
  fill(a: T) -> Sequence[T]:                      self.fill(a)
  fill(a: T, b: Int, c: Optional[Int]) -> Sequence[T]:self.fill(a, b, c)
  fill(a: T, b: Range[Int]) -> Sequence[T]:       self.fill(a, b)
  fill(a: Block[T]) -> Sequence[T]:               self.fill(a)
  fill(a: Int, b: Optional[Int], c: Block[T]) -> Sequence[T]:self.fill(a, b, c)
  fill(a: Range[Int], b: Block[T]) -> Sequence[T]:self.fill(a, b)
  index[T, U](a: U) -> Int:                       self.index(a)
  index(a: Block[Bool]) -> Int:                   self.index(a)
  index() -> Enumerator[T]:                       self.index()
  first() -> T:                                   self.first()
  first(a: Int) -> Sequence[T]:                   self.first(a)
  include_question[T, U](a: U) -> Bool:           self.include_quftion(a)
  initialize() -> self:                           self.initialize()
  initialize(a: Int) -> self:                     self.initialize(a)
  initialize(a: Int, b: T) -> self[T]:            self.initialize(a, b)
  inspect() -> String:                            self.inspect()
  join(a: Optional[String]) -> String:            self.join(a)
  keep_if(a: Block[Bool]) -> Sequence[T]:         self.keep_if(a)
  last() -> T:                                    self.last()
  last(a: Int) -> Sequence[T]:                    self.last(a)
  member[T, U](a: U) -> Bool:                     self.member(a)
  length() -> Int:                                self.length()
  permutation(a: Optional[Int]) -> Enumerator[T]: self.permutation(a)
  permutation(a: Optional[Int], b: Block[Any]) -> Sequence[T]:self.permutation(a, b)
  pop(a: Int) -> Sequence[T]:                     self.pop(a)
  pop() -> T:                                     self.pop()
  rassoc[T, U](a: U) -> T:                        self.rassoc(a)
  reject(a: Block[Bool]) -> Sequence[T]:          self.reject(a)
  reject() -> Enumerator[T]:                      self.reject()
  reject_bang(a: Block[Bool]) -> Sequence[T]:     self.reject_bang(a)
  reject_bang() -> Enumerator[T]:                 self.reject_bang()
  repeated_combination(a: Int, b: Block[Any]) -> Sequence[T]:self.repeated_combination(a, b)
  repeated_combination(a: Int) -> Enumerator[T]:  self.repeated_combination(a)
  repeated_permutation(a: Int, b: Block[Any]) -> Sequence[T]:self.repeated_permutation(a, b)
  repeated_permutation(a: Int) -> Enumerator[T]:  self.repeated_permutation(a)
  reverse() -> Sequence[T]:                       self.reverse()
  reverse_bang() -> Sequence[T]:                  self.reverse_bang()
  reverse_each(a: Block[Any]) -> Sequence[T]:     self.reverse_each(a)
  reverse_each() -> Enumerator[T]:                self.reverse_each()
  rindex[T, U](a: U) -> T:                        self.rindex(a)
  rindex(a: Block[Bool]) -> Int:                  self.rindex(a)
  rindex() -> Enumerator[T]:                      self.rindex()
  rotate(a: Optional[Int]) -> Sequence[T]:        self.rotate(a)
  rotate_bang(a: Optional[Int]) -> Sequence[T]:   self.rotate_bang(a)
  sample() -> T:                                  self.sample()
  sample(a: Int) -> Sequence[T]:                  self.sample(a)
  select(a: Block[Bool]) -> Sequence[T]:          self.select(a)
  select() -> Enumerator[T]:                      self.select()
  select_bang(a: Block[Bool]) -> Sequence[T]:     self.select_bang(a)
  select_bang() -> Enumerator[T]:                 self.select_bang()
  shift() -> T:                                   self.shift()
  shift(a: Int) -> Sequence[T]:                   self.shift(a)
  shuffle() -> Sequence[T]:                       self.shuffle()
  shuffle_bang() -> Sequence[T]:                  self.shuffle_bang()
  slice_bang(a: Range[Int]) -> Sequence[T]:       self.slice_bang(a)
  slice_bang(a: Int, b: Int) -> Sequence[T]:      self.slice_bang(a, b)
  slice_bang(a: Union[Int, Float]) -> T:          self.slice_bang(a)
  sort() -> Sequence[T]:                          self.sort()
  sort(a: Block[Int]) -> Sequence[T]:             self.sort(a)
  sort_bang() -> Sequence[T]:                     self.sort_bang()
  sort_bang(a: Block[Int]) -> Sequence[T]:        self.sort_bang(a)
  sort_by_bang[T, U](a: Block[U]) -> Sequence[T]: self.sort_by_bang(a)
  sort_by_bang() -> Enumerator[T]:                self.sort_by_bang()
  take(a: Int) -> Sequence[T]:                    self.take(a)
  take_while(a: Block[Bool]) -> Sequence[T]:      self.take_while(a)
  take_while() -> Enumerator[T]:                  self.take_while()
  to_a() -> Sequence[T]:                          self.to_a()
  to_ary() -> Sequence[T]:                        self.to_ary()
  transpose() -> Sequence[T]:                     self.transpose()
  uniq() -> Sequence[T]:                          self.uniq()
  uniq_bang() -> Sequence[T]:                     self.uniq_bang()
